# 高性能MYSQL



## MYSQL架构

1. **事务ACID指的都是那些特性**
2. **MYSQL的并发控制分为几个层面？那个层面的优先度高？**
3. **MYSQL锁的类型有哪些？**
4. **事务的隔离级别有哪些？ 都有那些特性？哪一个是InnoDB的默认隔离级别？**
5. **什么是脏读，幻读，可重复读，串行读？分别都有什么问题存在？**
6. **模拟一个死锁的查询,InnoDB是怎样处理死锁的？**
7. **InnoDB的MVVC(多版本并发控制)是怎样实现的?它可以解决什么问题？带来的利好和弊端都有哪些？**
8. MVVC增删改查时时怎样依赖/操作版本号的？
9. 乐观并发控制和悲观并发控制

## 以上问题

1. A：atomic  原子性 ， C：consistency 一致性  I：隔离性 isolation  D: durability 持久性

2. Mysql的并发控制分为 服务器层面和存储引擎层面，服务器层面你的优先级更高，且锁的力度更大

3. Mysql 的锁：按照隔离级别分为读写锁，其中读锁是共享锁，写锁是排他锁。按照锁的力度分为 表锁和行级锁，其中 Innodb已经支持行级锁

4. 事务的隔离级别

   1. 未提交读（uncommit read）： 事务中的修改即使没有提交，对其他事务也是可见的，即事务可以读取未提交的数据。这会导致**脏读的问题**
   2. 提交读（commit read）：也叫 不可重复读 ，  一个事务开始之后，只能读取自己事务内所做的修改。未提交之前，事务内的修改对其他事务是不可见的。 **这会导致事务中 一个查询在连续两次查询中会得到不同的结果，因为可能查询的事务已经处理完**
   3. 重复读（REPEATBLE READ） ，又称幻读。该级别解决了提交读的不可重复读的问题。即：在同一个事务中一个查询连续两次查询同一条数据的，结果是一致的。但是这又会导致一个**幻读**的问题，即事务内读到的数据可能已经被做了修改，读到的数据是其他事务做过修改的数据，而不是最新的数据。 z这个隔离级别是Mysql的默认隔离级别。 对于幻读，MYSQL中的**InnoDB 利用MVCC（并发版本控制）来解决**
   4. 可串行读（SERILIZABLE READ）, 解决了以上的所有的问题，但是效率低，在高数据一致性的应用上会使用，因为效率实在太低

   5： 脏读： 事务读到未提交数据  。 不可重复读： 事务内连续读同一条数据，得到不同结果 ， 幻读：事务读到的数据是旧的数据

   6： 死锁,两个事务在同一资源上相互占用， 对于死锁的处理，InnoDB目前的处理方式是，将持有最少行级排它锁的事务进行回滚

   7： MVCC可以有很多情况下避免加锁操作。读操作可以避免加锁操作，写操作也只锁定必要的行。MVVC 通过每行加上两个隐式行，一个保存行的创建时间，一个是过期时间。MVCC 只能够在REPEATABLE READ 和 READ COMMITED两个级别下工作

5. ​

   ​	

## MSYQL 服务器性能剖析

1. **只排查慢查询是不够的**
2. **性能剖析的两个步奏** ： 测量任务所花费时间，然后进行统计和排序，将重要的任务排在前面
3. **通过那个系统变量来设置慢查询的阈值**
4. **掌握好 INFORMATION_SCHEME 这个库下面的各个表**
5. **执行时间过长一般两个**
6. **利用USER_STATISTICS表**



## MYSQL 数据类型

1. **对于有些语句最后加‘\g’ 的含义是什么？**
2. **为什么列值最好不要为 null，如果为 null的话，对于该列对应的索引有何影响？**
3. **timestamp数据类型相对于datetime有何优势，有何劣势？**
4. **怎样使用吗，枚举类型代替字符串类型，那些应用场景更合适？**
5. **对于MYSQL 来说 int(1) 和int(20)有什么区别吗？**
6. **DECIMAL数据类型的作用**
7. **varchar和char型的区别，各自适用的业务场景**
8. **BOLB和TEXT的存储方式？ 排序的时候，这两种数据类型的特殊之处**
9. **标识列的数据类型选择**
10. **Mysql表的列太多会导致的问题**
11. **查询中太多的关联语句会造成的性能问题**
12. **第一范式，第二范式，第三范式，怎样分析业务表中存在不适于范式的设计？范式化和反范式化各自的优势**
13. **缓存表和汇总表带来的性能提升？**
14. **什么是计数器表？业务场景是什么?**



## MYSQL索引

1. **描述B+Tree 数据结构**

2. **B+ Tree 数据结构是怎样维护索引的？**

3. **B Tree索引存在的限制？**

4. **索引带来的三条优点**

5. **对于大中小各个规模的数据，索引是不是都是最优的选择？如果不是，怎么根据**

6. **Hash索引的优势与劣势？**

7. **BTree索引怎样通过模拟Hash索引来进行**

8. **Innodb是怎样使用Hash索引的？它带来的性能优化的点在哪里？**

9. **怎样计算索引列的选择性？写出对应的SQL语句**

10. **MYSQL中各个索引的命名都有那些**

11. **什么是覆盖索引？覆盖索引带来的优势？**

12. **对于联合索引，将选择性最高的列放入最前列，一般会是最佳的选择**

13.  **什么是聚簇索引？有什么用到的业务场景?有什么缺点**

14. **InnoDB的二级索引和聚簇索引的区别？怎样辨别一个索引是二级索引？还是聚簇索引? 那种索引在特定的业务场景中更有优势？**

15. **怎样才能让排序使用上索引？**

16. **MYSQL 的唯一 限制（unique）和主键（primary key）都是通过索引实现的。在这种列上面建立索引，犹如画蛇添足，影响写的性能**

17. **联合索引（A,B）和索引A  是不是退鱼索引？ （B,A）联合索引和索引A哪？**

18. **对于使用锁的类型来说,innoDB在访问主键索引和访问二级索引的区别在哪里？**

19. 如果表结构或索引有损坏，可以用那条语句快速修复？

20. Btree 需要进行随机访问才能访问到叶子节点，行碎片，行间碎片，剩余空间碎片

21. 可以定期使用那条语句来优化数据表？

22. **通过什么方式可以消除索引的碎片化？**

23. 编写查询语句时，应尽可能选择合适的索引以避免单行查找，尽可能第使用数据原生顺序，从而避免额外的排序操作，并尽可能的使用索引覆盖查询

    ​



 