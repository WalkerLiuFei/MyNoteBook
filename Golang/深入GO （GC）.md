# 深入GO （GC）

1. Go GC的基本特征是“**非分代**、**非紧缩**、**写屏障**、**并发标记清理(三色标记)**” 

2. `mgc.go` 是主要的算法实现部分，大部分的注释可以帮助立即，对外调用则在`GC()`函数中 

3. GC 分为三种模式 

   1. gcBackgroundMode ,同步阻塞模式： 会在 分配为对象分配内存时进行调用，也就是`malloc.go` 中的`mallocgc` 方法


2. 三色标记和写屏障 ：当完成这些操作后，所有的对象不是黑色的就是白色的，分别代表回收和活跃对象， GC时只需要回收这些白色的对象即可：

   1. 起初所有对象都是白色。
   2. 扫描找出所有可达对象，标记为灰色，放入待处理队列。、
   3. 从队列提取灰色对象，将其引用对象标记为灰色放入队列，自身标记为黑色。
   4. 写屏障监视对象内存修改，重新标色或放回队列。





   并发模式（Background Mode）垃圾回收过程示意图：

   ```
   ---------------------+--------------------------------------------------- 
                        | 
                   OFF+ --------> 准备MarkWorker/P，使其休眠待命 
                        | 
                      stop
                        | 
        B:1 BE:1]SCAN+ 
                        | 
                      start
                        | 
                        + --------> 并发扫描，将灰色对象放入队列 
                        |           对白色对象的引用修改被写屏障捕获 
                        |          Malloc分配白色对象 
                        |          MarkWorker被唤醒，开始标记任务 
                        | 
                  MARK+ 
                        | 
                        + --------> 等待第一轮标记结束 
                        |           第一轮处理的是并发扫描捕获的灰色对象，不包括新分配白色对象 
                        | 
                        + --------> 重新扫描DATA、BSS区域 
                        |           扫描新分配白色对象 
                        | 
                        + --------> 等待第二轮标记结束 
                        | 
                      stop
                        | 
                 [BE:0] + 
                        | 
      MARK TERMINATION+ 
                        | 
                        + -------->STW冻结，完成最终标记 
                        | 
             [WB:0]OFF+ 
                        | 
                        + --------> 并发清理 
                        | 
                        start   
                        | 
                                                       STW:StopTheWorld
                                                       WB:WriteBarrierEnabled
                                                       BE:BlackenEnabled
   ```

### 标记

1. 并发标记分为两个步骤： 扫描和标记
2. 在扫描时，
3. 并发标记由多个MarkWorker goroutine共同完成，它们在回收任务开始前被绑定到P，然后进入休眠状态，直到被调度器唤醒
4. 调度函数schedule从控制器gcController获取MarkWorker goroutine并执行。
5. MarkWorker有3种工作模式。
   1. gcMarkWorkerDedicatedMode：全力运行，直到并发标记任务结束。
   2. gcMarkWorkerFractionMode : 参与标记任务，可被强占和调度
   3. gcMarkWorkIdleMode : 仅在空闲时参与标记任务

​	



## 其他

[参考](https://studygolang.com/articles/14221) 

### GC 理论基础 

下面是在设计垃圾收集算法时您想要考虑的不同因素：

- 程序吞吐量：你的算法在多大程度上减慢程序？这表示为花费在执行垃圾收集与工作时间的百分比。
- GC吞吐量：在给定CPU时间内多少垃圾可以被收集器清除？
- 堆开销：你的收集器需要多少额外的内存？如果你的算法在收集时分配临时内存，是否会使你的程序的内存使用突然暴涨？
- 暂停时间：你的垃圾收集器STW时间 ？
- 暂停频率：你的垃圾收集器多久暂停一次程序？
- 暂停分布：有时有非常短暂的停顿，但有时会有很长的停顿。
- 内存分配性能：分配新内存的时候是快还是慢？或者性能不可预测？
- 整理：因为内存碎片的原因，在有足够的可用空间可满足请求，垃圾收集器是否会报告内存不足（OOM）错误？
- 并发：垃圾收集器如何使用多核？
- 扩展性：你的垃圾收集器随着堆增大工作情况如何？
- 调优：垃圾收集器的配置有多复杂，可以开箱即用并获得最佳性能吗？
- 预热时间：垃圾收集算法是否基于测量行为进行自适应调整？需要多长时间才能达到最佳？
- 内存释放：您的算法是否释放未使用的内存回到操作系统？如果是，什么时候释放？
- 可移植性：您的垃圾收集器是否可以在提供比x86更弱的内存一致性保证的CPU体系结构上工作？
- 兼容性：您的垃圾收集器使用哪些语言和编译器？它可以与设计时没有考虑GC的语言（如 C++）一起工作吗？它需要修改编译器吗？如果是这样，更改GC算法是否需要重新编译所有程序和依赖关系？

### 权衡（tradeoff）的艺术

对于GC时要不要暂停程序的问题，其实是一个权衡的结果，对于

### Golang GC带来的缺陷和优点

Golang的并发式的三色标记GC算法，使得程序暂停时间很短，但是它同样带来其他的一些问题

1. GC吞吐量：GC时间与堆大小同步增长。
2. 整理：因为没有整理，GC 过程会产生内存碎片。程序也不会受益于在缓存中整齐排列的内容。
3. 程序吞吐量：因为GC必须在每个周期做很多工作，所以会消耗不少CPU时间。
4. 暂停分布：与程序并发运行的任何垃圾收集器都可能遇到Java中“并发模式失败”的问题：您的程序创建垃圾的速度比GC线程可以清除它快。在这种情况下，runtime别无选择只能完全停止程序，等待GC完成垃圾收集。因此当Go团队声明GC暂停非常低时，该声明只能适用于GC具有足够的CPU时间和空间以完成垃圾回收的情况。另外，由于Go编译器缺乏确保线程可以被快速可靠暂停这一功能，会导致暂停时间是否很低取决于您运行的是什么类型的代码（例如，base64 解码单个 goroutine 中的大 blob 会导致暂停时间上升）。
5. 堆开销：**因为通过标记/扫描收集堆非常慢，您需要大量的空间以确保不会遇见“并发模式故障”。 Go默认使用100％的堆开销会让程序需要的内存量增加一倍**。 

### 与 Java 对比

1. HotSpot JVM 有几个 GC 算法，您可以在命令行中选择。因为他需要平衡其他各种因素，因此没有一个 GC 算法的目标能将暂停时间降低到 Go 水平。
2. java 的 默认GC 算法是吞吐量收集器（throughput collector）。这是为批处理作业设计的，默认情况下没有任何暂停时间目标。这种默认选择也是人们认为 Java GC 有点吸引力的一个原因：开箱即用，它试图使您的应用程序尽可能快地运行，并尽可能少的内存开销，而暂停时间不是该算法首要考虑的。
3. 如果想要尽可能的缩短暂停时间，可以选择 CMS （concurrent mark / sweep）算法 ,但它也是分代的，所以其暂停时间也要比Go的长,因为需要在年轻代整理并移动对象，而导致应用程序暂停。