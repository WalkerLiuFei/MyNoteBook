# 深入GO（Golang 内存池管理）

## 内存池

1. Go的内存分配器采用了跟**tcmalloc**库相同的实现，是一个带内存池的分配器，底层直接调用操作系统的mmap等函数。

2. 使用到内存池就要考虑内存池的使用效率，避免碎片化 ： [内存管理算法](https://www.geeksforgeeks.org/operating-system-memory-management-partition-allocation-method/) ，[内存管理](https://www.geeksforgeeks.org/tag/os-memory-management/) 
   1. **[首次适应](https://baike.baidu.com/item/%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95)** ： 从空闲分区表的**第一个**表目起查找该表，把最先能够满足要求的空闲区分配给作业，这种方法的目的在于减少查找时间。
   2. **最佳适应算法（best-fit）**：从全部空闲区中找出能满足作业要求的，且**大小最小**的空闲分区，这种方法能使碎片尽量小。
   3. **最差适应算法（worst-fit）** ：它从全部空闲区中找出能满足作业要求的、且**大小最大**的空闲分区，从而使链表中的节点大小趋于均匀。
   4. [伙伴算法](https://blog.csdn.net/orange_os/article/details/7392986) 

3. **Go中为每个系统线程分配一个本地的MCache(前面介绍的结构体M中的MCache域)**，少量的地址分配就直接从MCache中分配，并且定期做垃圾回收，将线程的MCache中的空闲内存返回给全局控制堆。

4. **小于32K的为小对象，直接从Mcache域上获取**，大对象直接从全局控制堆上以页(4k)为单位进行分配，也就是说大对象总是以页对齐的。

5. 分配器的数据结构包括:
   - FixAlloc: 固定大小(128kB)的对象的空闲链分配器,被分配器用于管理存储
   - MHeap: 分配堆,按页的粒度进行管理(4kB)
   - MSpan: 一些由MHeap管理的页
   - MCentral: 对于给定尺寸类别的共享的free  span list
   - MCache: 用于小对象的每M一个的cache

6. **我们可以将Go语言的内存管理看成一个两级的内存管理结构，MHeap和MCache。上面一级管理的基本单位是页，用于分配大对象，每次分配都是若干连续的页，也就是若干个4KB的大小。使用的数据结构是MHeap和MSpan，用BestFit算法做分配，用位示图做回收**。下面一级管理的基本单位是不同类型的固定大小的对象，更像一个对象池而不是内存池，用引用计数做回收。下面这一级使用的数据结构是MCache。

7. GO 内存的分配策略,内存分配器只管理内存块，并不关心对象状态。且它不会主动回收内存，垃圾回收器在完成清理操作后，触发内存分配器的回收操作。

   1．每次从操作系统申请一大块内存（比如1MB），以减少系统调用。    

   2．将申请到的大块内存按照特定大小预先切分成小块，构成链表。    

   3．为对象分配内存时，只须从大小合适的链表提取一个小块即可。    

   4．回收对象内存时，将该小块内存重新归还到原链表，以便复用。    

   5．如闲置内存过多，则尝试归还部分内存给操作系统，降低整体开销。

8. 分配器将其管理的内存块分为两种。


       span：由多个地址连续的页（page）组成的大块内存。
       
       object：将span按特定大小切分成多个小块，每个小块可存储一个对象。object按照字节以8的倍数分为n种，例如大小为24 byte的object可以用来存储 17-24 字节大小的object
    
     按照其用途，span面向内部管理，object面向对象分配。

9. 分配器由三种组件组成。


    cache：每个运行期工作线程都会绑定一个cache，用于无锁object分配。
    
    central：为所有cache提供切分好的后备span资源。
    
    heap：管理闲置span，需要时向操作系统申请新内存。
10. Golang 为new object 分配内存的流程

     1．计算待分配对象对应的规格（size class）。

     2．从`cache.alloc`数组找到规格相同的span。

     3．从`span.freelist`链表提取可用object。

     4．如`span.freelist`为空，从`central`获取新`span`。

     5．如`central.nonempty`为空，从`heap.free/freelarge`获取，并切分成object链表。

     6．如`heap`没有大小合适的闲置`span`，向操作系统申请新内存块

     **对于大对象的内存分配，他的内存是直接从 heap分配和回收的**

11. 释放流程：  

    1．将标记为可回收的object交还给所属span.freelist。    

    2．该span被放回central，可供任意cache重新获取使用。    

    3．如span已收回全部object，则将其交还给heap，以便重新切分复用。    

    4．定期扫描heap里长时间闲置的span，释放其占用的内存。

12. | 页所属span指针数组 | GC标记位图  | 用户内存分配区域 |
    | ------------------ | ----------- | ---------------- |
    | spans 512MB        | bitmap 32GB | arena 512GB      |

13. Golang会尽量避免在栈和寄存器上面分配内存，而不是在堆上分配内存，这样会减轻GC的工作负担

14. 对微小对象的处理很有意思。首先，它不能是指针，因为多个小对象被组合到一个object里，显然无法应对垃圾扫描。其次，它从span.freelist获取一个16字节的object，然后利用偏移量来记录下一次分配的位置。

15. GC 回收的单位是以Span为单位的

16. 在heap里闲置的span不会被垃圾回收器关注，但central里的span却有可能正在被清理。所以当cache从central提取span时，该属性值就非常重要。

17. 基于效率考虑，回收操作自然不会直接盯着单个对象，而是以**`span`**为基本单位。通过比对bitmap里的扫描标记，逐步将object收归原span，最终上交central或heap复用

18. 内存回收的来源是垃圾清理，内存管理的重心在于内存复用，只有在空闲内存资源太多时才会被释放

19. 分配算法优先从复用链表获取内存，只有获取失败或剩余空间不足时才会去申请新的内存块

##  golang 内存管理算法 ： tcmalloc

