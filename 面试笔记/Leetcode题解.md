---
title: Leetcode 解题笔记（一）
---

# <a href="https://leetcode.com/problems/single-number-ii/">Single Number II</a>

+ 一个数列，除了一个数，其他数都出现3次。这里用了一个 长度为32的数组，维护32个位，各位出现的次数，然后对3取 %


```Java

public int singleNumber(int[] nums) {
	    int ans = 0;
	    for(int i = 0; i < 32; i++) {
	        int sum = 0;
	        for(int j = 0; j < nums.length; j++) {
	            if(((nums[j] >> i) & 1) == 1) {
	                sum++;
	                sum %= 3;
	            }
	        }
	        if(sum != 0) {
	            ans |= sum << i;
	        }
	    }
	    return ans;
	}

```
# 堆排序问题

## 最小堆排序
## 最大堆排序

# 第K大问题

这个问题的解法分为两种情况，数很大和很小的两种。如果待筛选的数据很大，例如百万级别的数据保存在硬盘上，如果将其一起读入到内存中进行处理肯定非常影响性能，这个时候可以利用一个容量为K的最小堆。然后将数往这个最小堆里面读，读取待筛选数据集，然后维护这个最小堆。**最小堆排序** 时间复杂度O(n * logk)

利用快速排序的思想，选定一个数然后利用快速排序的思想，利用这个数 X 将数据集合 Array 分割为两部分，SA 和SB，SA 中数全部小于X ，SB 的数全部大于 X。这时候
  
1. **Sa中元素的个数小于k** ，则Sb中的第k-|Sa|个元素即为第k大数；
2. **Sa中元素的个数大于等于k**，则返回Sa中的第k大数。时间复杂度近似为O(n)

	
# 典型的Greedy问题题解

## <a href = "http://blog.csdn.net/yutianzuijin/article/details/45116705#">Interval Sceduling</a>

+ 在区间排序的问题上，一般都是需要先排序。以为区间排序以后，其实都已经有了一个先后顺序，后续再进行重叠判断的时候只需要比较一次即可

+ 对于重叠的区间，我们可以扩展到二维平面上。纵坐标为区间 ID，横坐标为区间所占的时间。。。也就是说，对于纵坐标的指定的相对于X轴的每一个集合，是没有重叠的
![](http://img.blog.csdn.net/20150418214141782)

### 最多区间问题 （贪心算法）
 
问题描述： 在有限的时间内尽可能参加多的工作任务，并且保证参加的工作任务在时间上没有重叠。

贪心策略：在**可选的**工作中，每次都选取结束时间最早的工作。这样可以保证参加更多的工作。

题解思想：先对要参加任务根据任务结束时间进行排序。然后在可选的任务集合中(和前面的已参加过的任务在时间上没有冲突) **选择结束时间最早的**作为要参加的任务

### 最大区间问题 （动态规划）

问题描述：假设给定你的一定时间的，和一个任务集合。现在的要求是在你工作时间范围内尽可能多的不闲着。也就是说求一个最大没有时间冲突的任务集合
 
动态规划方程 ：这里并没有一个特定的贪心策略，所以贪心算法在这个问题并不适用。在这里动态规划更合适，首先根据结束时间排序， **DP[i] 为每个工作和前面和这个工作没有时间冲突的时间集合的和！** 所以
**DP[i] = max(DP[i-1],DP[lastNotOverlapIndex] + time )**即为动态规划方程。 方程中的lastNotOverlapIndex为当前这个index上一个没有重叠的任务 
