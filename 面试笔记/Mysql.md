---
titl: Mysql相关知识点
---
## 事务处理

+ ACID 性质
 + 原子性（Atmoic）：用于标示事务事务是否完全完成。对于事务而言，其所有的操作都在内存中执行，只有当所有的操作都完成 成功后，才会永久化写入到硬盘。
 + 一致性(consistence)：事务在系统完整性中实施一致性，通过保证系统的任何事务最后都处于有效状态来实现。事务出错，系统将返回原始状态
 + 隔离性(isolation)： 为防止混乱，再两个事务同时执行时，使用乐观锁的机制，保证对同一数据，同一时间只有一个请求在对其访问。隔离性保证了，在本次事务完成之前，其他操作对于数据的访问都不会受到未完成事务的影响
 + 事务的回滚并不能释放锁
## Mysql 锁

+ 排它锁（写锁）：若事务T对对象A加上X锁，则只允许T读取和修改A，其他任何事务不得对A加任何锁，直至T释放A的锁。这就意味着T在释放A之前无法读取和修改A
+ 共享锁（读锁）：若事务T对对象A加上S锁，其他事务可以访问对象A，但是不能为其添加X锁，知道事务T对对象释放了锁S	
+ 更新锁： 未解决死锁而引入的概念
+ 在InnoDB存储引擎中，UPdate 操作会将所有你要更新的数据列加锁，这样会相对的影响更新效率

## 处理并发问题的步奏：

+ 开启事务
+ 申请写权限，给对象加锁
 + 失败。稍后重试
+ 成功，进行编辑操作
+ 写入编辑的结果
+ 写入成功，则提交事务完成操作
+ 写入失败，回滚事务


# JDBC 连接池

+ 连接池的作用，用来避免客户端在连接数据库时频繁的建立连接导致的性能问题
+ 静态连接池：连接在系统初始化时就已经分配好，不能随意关闭。。
+ 连接池的复用策略同Java的 GC 一样使用 reference count（引用计数）算法。空闲的连接优先分配给客户端来使用。如果
+ 连接池最大连接和最小连接数需要在实践中确定
+ 连接池管理的事务处理：每一个事务独占一个连接，JDBC 通过建立一个事务注册表，以Thread作为ID 来标识使用者。
+ 虽然事务连接和普通连接的分配策略不一致，但JavaAPI通过多态均将这些操作封装到了DBCollections 接口中

# Btree
> B树是一种自平衡树 （Balance tree）


+ B树的一个 比较好理解的数据结构是 2 - 3树,父节点的关键码的数量必须是其子节点的 -1 ；即 k的关键码，其子节点为 k-1 个可类比于2~3树,
+ 2 - 3 树的数据结构其实就是一个 3 阶的B树
+ B树存储的都是主关键码？对主关键码（Index）进行索引来进行查找？
+ Mysql表中每个索引都会以B树的数据结构建立一个文件，查找数据时可以对其进行缩短查找的时间复杂度 从 O（N） 缩短到 O（LogN）
+ 时间复杂度
 + 搜索O(log n) 
 + 插入O log n 
 + 插入 O log n 
 + 删除 O logn
+ B树的性质
 + 根结点只有1个，关键字字数的范围[1,m-1]，分支数量范围[2,m]；
 + 除根以外的非叶结点，每个结点包含分支数范围[[m/2],m]，即关键字字数的范围是[[m/2]-1,m-1]，其中[m/2]表示取大于m/2的最小整数；
 + 非叶结点是由叶结点分裂而来的，所以叶结点关键字个数也满足[[m/2]-1,m-1]；
 + 所有的非终端结点包含信息：(n，P0，K1，P1，K2，P2，……，Kn，Pn)，

     其中Ki为关键字，Pi为指向子树根结点的指针，并且Pi-1所指子树中的关键字均小于Ki，而Pi所指的关键字均大于Ki（i=1，2，……，n），n+1表示B-树的阶，n表示关键字个数，即[ceil(m / 2)-1]<= n <= m-1；

 + 所有叶子结点都在同一层，并且指针域为空，具有如下性质：
+ **删除和更新，插入时要保持树的平衡，这个比较复杂**

# 其他

+ Innodb 中的日志： 
 + binlog：二进制日志
 + 查询日志：
 + 慢日志
 + 错误日志
 + 中继日志：

# Mysql锁的问题

## MyISAM 的锁 
+ MyISAM总是一次SQL语句需要的全部锁，这也是为什么MyISAM表不会出现死锁的原因。
+ 在一个session中显式的为一个表加读锁后，通过别名读取这个锁，同样会被拒绝
+ 在MyISAM中，Session在获取一个表的读锁后，就不能再查询/更新其他表
+ **MyISAM中写锁的优先级总是高于读锁，这也是为什么MyISAM不适合大量更新和查询操作的原因**
+ Mysql的并发插入机制 通过一个系统变量 concurrent_insert 进行

## InnoDB 锁

> InnoDB的特性就是支持事务和行级锁

+ 事务及其ACID 属性
 + 原子性(Atmoicty)：事务是一个原子操作单元，其对数据的修改要么全部完成，要么全部回滚
 + 一致性（Consistent）：在事务开始和完成时 ，数据
 + 隔离性（Isolation）
 + 持久性（Durable） ：事务完成后，它对数据的修改是永久性的。
+ 通过检查 InnoDB_row_lock状态变量可以分析系统上的行锁争用状况

InnoDB的两种锁：
+ 共享锁：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁
+ 排它锁：允许排它锁的事务更新数据，组织其他事务获得相同数据集的
+ InnoDB行锁的三种情形，**简洁的说，InnoDB对数据的加锁都是通过索引对数据的加锁**
 + Record lock ：对缩影加锁
 + Gap lock：对索引项之间“间隙“ 加锁
 + Next-key lock ： 前面两种的组合，对索引项和前面的间隙加锁
 
+　**InnoDB的这种行锁机制意味着，如果不对数据加索引，那么InnoDB将对所有记录都加锁，效果和表锁没有区别**
+　在分析InnoDB的锁冲突时不要忘记检查是否使用了索引
+　**通过设置合适的锁等待超时阈值，可以避免死锁带来问题**
+ **避免死锁的措施**
 + 在应用中，如果不同的程序会并发的访问不同的表，应尽量以相同顺序去访问表，这样可以大大降低发生死锁的几率
 + 在程序以批量处理方式处理数据时，如果事先对数据排序，保证每个线程按固定的顺序来处理数据，可以大大降低出现死锁的可能
 + 在事务中，直接申请足够级别的锁，即排它锁
 + 尽量使用较低的隔离级别
 + 精心设计索引，使得加锁更精确，减少锁冲突
 + 选择合适的事务大小，小事务发生的锁冲突几率更小
 
+　在出现死锁时，利用show innoDB status命令来确定最后一个死锁出现的原因