---
title:java并发编程实战读书笔记
---
## 第一章

+ 线程拥有自己的程序计数器，栈，本地变量
+ 同一个程序内的多个线程可以在多CPU的情况下同时进行
+ 线程为CPU时序调控的最基本单元

## 第二章 线程安全
+ 原子性：即原子性操作，即同一块相互关联的代码逻辑在同一时间只能有一个线程进行访问。 例如：if(a<10) a++，这个代码涉及到 读-读-改-写，四个连续的操作。（很容易理解）
 原子操作时不可中断的，不可分割的。
 + 竞争条件： 不是所有的竞争条件都是数据竞争，竞争条件并不总是导致失败。
 + 数据竞争： 
+ 不论怎样，线程安全包括原子性和可见性两个方面
+ 对于每个可被多个线程访问的可变状态变量，如果所有的访问，如果所有访问它的资源在执行时都占有同一个锁，我们称这个变量由这个锁保护。
+ 每个可变变量都需要由唯一一个确定的锁保护，而维护者应该清楚这个锁。
+ 为了保证性能，应该致使synchronized 代码块足够短。
+ 执行耗时计算时，不应该占有所

## 第三章 可见性
+ Volatile:保证数据不过期
+ 锁不仅仅是关于同步与互斥，也是关于内存可见的。
+ 正确应用volatile的方式： 用于确保它们所引用的对象状态的可见性，或者用于标示重要的生命周期事件的发生。
+ 使用volatile变量的标准
 + 写入变量时并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值
 + 变量不需要与其他的状态变量共同参与不变约束
 + 访问变量时没有额外的原因加锁
+ JDBC 并没有要求connection是线程安全的，但是在应用中，connection 会从线程池中获取一个实例，并且在connection完成操作归还给线程池之前，线程池不会将connection分配给其他线呈
+ 线程限制技术： 例如Android的UI线程
+ ThreadLocal 是本地化的最规范的方式，应用很广、
+ 为临时缓存这种简单的事务而直接使用ThreadLocal并没有什么性能优势。在java5.0中，它被一种更直接的方式取代，就是为为每一次调用分配一个新的缓冲区
+ 对象的引用和以及对象的状态必须同事对其他线程可见。一个正确创建的对象可以通过下面的条件安全的发布
 + 通过静态初始化器初始化对象的引用
 + 将它的引用存储到volatile域或者AtomicReference
 + 将它的引用存储到正确创建的对象的final域中
 + 将它的引用存储到由锁正确保护的域中
+ 不可变对象可以在没有额外同步的情况下，安全的用于任意线程，甚至发布它们时亦不需要同步
+ 　一个线程安全的对象在内部进行同步，所以其他线程无需额外同步，就可以通过公共接口随意访问它
+ 　一个被守护的对象只能通过特定的锁来访问，被守护的对象包括那些被线程安全对象封装的对象，和已知被特定的锁保护起来的已发布的对象

##　第四章
