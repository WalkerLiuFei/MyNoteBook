---
title:贪心算法
---

# 概念

 *贪心法*，又称贪心算法、贪婪算法、或称贪婪法，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。[1]比如在旅行推销员问题中，如果旅行员每次都选择最近的城市，那这就是一种贪心算法。

+ **与动态规划的区别**：贪心算法与动态规划的不同在于它每对每个子问题的解决方案都做出选择，不能回退。动态规划会保存以前的运算结果。并根据保存的结果对当前进行选择，有回退功能
+ **贪心算法的应用**：解决一些最优化问题，如求图的最小生成树，求哈夫曼编码等。
+ **贪心算法的五个组成部分**
 + 候选集合C: 从要解决问题中抽象出一个候选集合，问题的最终解都来自与这个解集合中， 
 + 解集合S:随着贪心选择的进行，解集合S不断扩展，直到构成一个满足问题的完整解。
 + 解决函数solution:检查解集合S是否构成问题的完整解
 + 选择函数select:即贪心策略，这是贪心法的关键，它指出那个候选对象最有希望构成问题的解，选择函数通常和目标函数有关。
 + 可行函数feasible：检查解集合中加入一个候选对象是否可行，即解集合扩展后是否满足约束条件。

+ **解决贪心问题的一般套路**
 + 建立数学模型描述问题
 + 把求解的问题组成若干个子问题
 + 对每一个子问题求解，得到子问题的局部最优解
 + 合并子问题子问题的最优解，求出全局的最优解
+ **伪代码**：
   <pre> Greedy(C)  //C是问题的输入集合即候选集合
  
  {
    S={ };  //初始解集合为空集
    while (not solution(S))  //集合S没有构成问题的一个解
    {
       x=select(C);    //在候选集合C中做贪心选择
       if feasible(S, x)  //判断集合S中加入x后的解是否可行
          S=S+{x};
          C=C-{x};
    }
  </pre>

# 案例

## 找零钱

**讲解**<br>
一个小孩买了价值少于1美元的糖，并将1美元的钱交给售货员。售货员希望用数目最少的硬币找给小孩。假设提供了数目不限的面值为2 5美分、1 0美分、5美分、及1美分的硬币。售货员分步骤组成要找的零钱数，每次加入一个硬币。选择硬币时所采用的贪婪准则如下：每一次选择应使零钱数尽量增大。为保证解法的可行性（即：所给的零钱等于要找的零钱数），所选择的硬币不应使零钱总数超过最终所需的数目

**引例分析** <br>
为使找回的零钱的硬币数最小，不考虑找零钱的所有各种方案，**而是从最大面值的币种开始，按递减的顺序考虑各币种，先尽量用大面值的币种，只当不足大面值币种的金额才会去考虑下一种较小面值的币种。这就是在采用贪婪法。**这种方法在这里之所以总是最优，是因为银行对其发行的硬币种类和硬币面值的巧妙安排。如果只有面值分别为1，5和11单位的硬币，而希望找回总额为15单位的硬币，按贪婪算法，应找1个11单位面值的硬币和4个1单位面值的硬币，共找回5个硬币。但最优的解答应是3个5单位面值的硬币。
