#开关指示灯
##命令号
<pre>
    public static final int IOTYPE_USER_IPCAM_SETIO_REQ = 1622;
    public static final int IOTYPE_USER_IPCAM_SETIO_RESP = 1623;
</pre>
##结构体
<pre>
	struct SMIO{
		int avIndex;
		int ioType; // 0是关闭，1是打开
	}
</pre>
#宽动态
##私有协议结构体
<pre>
    struct TagPacket {
		<a href="#">注意这下面的四个int 其实是一个整形</a>
        int nPacketType;        //包的类型 0----5 
        int nPacketCount;        //包总数  5 -- 13
        int nPacketID;        //包序号     13 ----21
        int nPacketLen;        //包的长度  21-----32
        char[] acData;     //length 128,

     
    }

    struct TagExtend {
        int nType;
        int nParam1;
        int nParam2;
        int nParam3;
        char[] acData;  //length 128 - 20,减20的原因是要把它放到acData中？
    }
</pre>
##命令号
<pre>
    //存储管理指令;lck20120306
    public static int EX_STORAGE_REFRESH = 0x01;
    public static int EX_STORAGE_REC = 0x02;
    public static int EX_STORAGE_OK = 0x04;
    public static int EX_STORAGE_ERR = 0x05;
    public static int EX_STORAGE_FORMAT = 0x06;
    public static int EX_STORAGE_SWITCH = 0x07;

    //远程控制指令
    public static byte RC_DISCOVER = 0x01;
    public static byte RC_GETPARAM = 0x02;
    public static byte RC_SETPARAM = 0x03;
    public static byte RC_VERITY = 0x04;
    public static byte RC_LOADDLG = 0x05;
    public static byte RC_EXTEND = 0x06;
    public static byte RC_USERLIST = 0x07;
    public static byte RC_PRODUCTREG = 0X08;
    public static byte RC_GETSYSTIME = 0x09;
    public static byte RC_SETSYSTIME = 0x0a;
    public static byte RC_DEVRESTORE = 0x0b;
    public static byte RC_SETPARAMOK = 0x0c;
    public static byte RC_DVRBUSY = 0X0d;
    public static byte RC_GETDEVLOG = 0x0e;
    public static byte RC_DISCOVER_CSST = 0x0f;
    //扩展类型，用于指定哪个模块去处理;lck20120
    public static byte RC_EX_FIRMUP = 0x01;
    public static byte RC_EX_NETWORK = 0x02;
    public static byte RC_EX_STORAGE = 0x03;
    public static byte RC_EX_ACCOUNT = 0x04;
    public static byte RC_EX_PRIVACY = 0x05;
    public static byte RC_EX_MD = 0x06;
    public static byte RC_EX_ALARM = 0x07;
    public static byte RC_EX_SENSOR = 0x08;
    public static byte RC_EX_PTZ = 0x09;
    public static byte RC_EX_AUDIO = 0x0a;
    public static byte RC_EX_ALARMIN = 0x0b;
    public static byte RC_EX_REGISTER = 0x0c;
    public static byte RC_EX_EXPOSURE = 0x0d;
    public static byte RC_EX_QRCODE = 0x0e;
    public static byte RC_EX_IVP = 0x0f;
    public static byte RC_EX_DOORALARM = 0x10;
    public static byte RC_EX_PTZUPDATE = 0x11;
    public static byte RC_EX_COMTRANS = 0x12;
    //------------------sensor设置-----------------------------------
    public static byte EX_SENSOR_REFRESH = 0x01;
    public static byte EX_SENSOR_SUBMIT = 0x02;
    public static byte EX_SENSOR_CANCEL = 0x03;
    public static byte EX_SENSOR_SAVE = 0x04;
</pre>
#宽动态的具体设置
<pre>
    public static boolean sendDynamic(int avIndex,String message) {
        byte[] data = message.getBytes();
        return sendPrivateCommand(avIndex,AVIOCTRLDEFs.EX_SENSOR_SAVE,AVIOCTRLDEFs.RC_EXTEND,AVIOCTRLDEFs.RC_EX_SENSOR,(byte) 40,data);
    }

    private static boolean sendPrivateCommand(int avIndex, int exCommand, byte rcExtend, byte rcExCommand, byte length, byte[] data) {
        AVAPIs avapIs = getDefault();
        byte[] extendData = AVIOCTRLDEFs.TagExtend.parseContent(exCommand, data);
        byte[] packetData = AVIOCTRLDEFs.TagPacket.parseExContent(rcExtend, rcExCommand,  length,extendData);
        int ac = avapIs.avSendIOCtrl(avIndex, AVIOCTRLDEFs.ACCESS_AV_CONFIG, packetData, packetData.length + 1);
        if (ac < 0)
            AVAPIs.showErrorMsg(TAG,ac);
        return ac > 0;
    }
</pre>